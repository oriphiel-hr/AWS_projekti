name: Backend - Reuse existing Task Definition (ECR‚ÜíECS)

on:
  push:
    branches: [ "main" ]
    paths:
      - "uslugar/backend/**"
      - ".github/workflows/backend-uslugar-ecs.yml"

env:
  AWS_REGION: eu-north-1
  ECR_REPO_BACKEND: uslugar
  ECS_CLUSTER: apps-cluster
  ECS_SERVICE: uslugar-service-2gk1f1mv
  CONTAINER_NAME: uslugar
  # üîΩ Privatni subneti i SG za Fargate task koji ƒáe pokrenuti migracije
  MIGRATE_SUBNETS: subnet-0a00f97768705bbcf,subnet-01b67edfd00dc288c
  MIGRATE_SG: sg-084c1e49c9c77aff1

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions: { id-token: write, contents: read }

    steps:
      - uses: actions/checkout@v4

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - id: ecr-login
        uses: aws-actions/amazon-ecr-login@v2

      # üîë Generiraj package-lock.json ako ga nema (za npm ci u Dockerfileu)
      - name: Generate package-lock.json (backend)
        run: |
          cd uslugar/backend
          if [ ! -f package-lock.json ]; then
            echo "No package-lock.json found, generating..."
            npm i --package-lock-only
          fi
          head -n 20 package-lock.json || true

      - name: Build & Push image
        env:
          ECR_REGISTRY: ${{ steps.ecr-login.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -f uslugar/backend/Dockerfile.prod \
            -t $ECR_REGISTRY/${{ env.ECR_REPO_BACKEND }}:$IMAGE_TAG uslugar/backend
          docker push $ECR_REGISTRY/${{ env.ECR_REPO_BACKEND }}:$IMAGE_TAG
          echo "IMAGE_URI=$ECR_REGISTRY/${{ env.ECR_REPO_BACKEND }}:$IMAGE_TAG" >> $GITHUB_ENV

      - name: Install JQ
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Read current Task Definition
        run: |
          TD_ARN=$(aws ecs describe-services \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --services "${{ env.ECS_SERVICE }}" \
            --query "services[0].taskDefinition" --output text)
          echo "Using task definition: $TD_ARN"
          aws ecs describe-task-definition --task-definition "$TD_ARN" \
            --query "taskDefinition" > td.json

          # Oƒçisti nedopu≈°tena/meta polja prije register-task-definition
          jq 'del(
            .status,
            .requiresAttributes,
            .compatibilities,
            .revision,
            .registeredAt,
            .registeredBy,
            .deregisteredAt,
            .taskDefinitionArn,
            .tags,
            .inferenceAccelerators
          )' td.json > td_clean.json

      - name: Replace image in TD
        run: |
          jq --arg NAME "${{ env.CONTAINER_NAME }}" --arg IMG "${IMAGE_URI}" '
            .containerDefinitions = (.containerDefinitions | map(
              if .name == $NAME then .image = $IMG | . else . end
            ))
          ' td_clean.json > td_new.json
          echo "New image for container '${{ env.CONTAINER_NAME }}': ${IMAGE_URI}"

      - name: Register new TD revision
        run: |
          NEW_TD_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://td_new.json \
            --query "taskDefinition.taskDefinitionArn" --output text)
          echo "NEW_TD_ARN=$NEW_TD_ARN" >> $GITHUB_ENV
          echo "Registered: $NEW_TD_ARN"

      - name: Update service
        run: |
          aws ecs update-service \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --service "${{ env.ECS_SERVICE }}" \
            --task-definition "${NEW_TD_ARN}" \
            --query "service.taskDefinition" --output text

      # ‚úÖ Post-deploy: pokreni Prisma migracije kao privremeni Fargate task
      - name: Run Prisma Migrate (post-deploy)
        run: |
          echo "Running prisma migrate deploy on new TD: ${NEW_TD_ARN}"
          TASK_ARN=$(aws ecs run-task \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --launch-type FARGATE \
            --task-definition "${NEW_TD_ARN}" \
            --network-configuration "awsvpcConfiguration={subnets=[${{ env.MIGRATE_SUBNETS }}],securityGroups=[${{ env.MIGRATE_SG }}],assignPublicIp=DISABLED}" \
            --overrides "{\"containerOverrides\":[{\"name\":\"${{ env.CONTAINER_NAME }}\",\"command\":[\"npx\",\"prisma\",\"migrate\",\"deploy\"]}]}" \
            --region "${{ env.AWS_REGION }}" \
            --query "tasks[0].taskArn" --output text)
          echo "Started migrate task: $TASK_ARN"

          # (opcionalno) ƒçekaj da task zavr≈°i i prika≈æi status
          aws ecs wait tasks-stopped \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --tasks "$TASK_ARN"
          EXIT_CODE=$(aws ecs describe-tasks \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --tasks "$TASK_ARN" \
            --query "tasks[0].containers[?name=='${{ env.CONTAINER_NAME }}'].exitCode | [0]" \
            --output text)
          echo "Migrate task exit code: $EXIT_CODE"
          if [ "$EXIT_CODE" != "0" ]; then
            echo "Prisma migrate failed"; exit 1;
          fi
