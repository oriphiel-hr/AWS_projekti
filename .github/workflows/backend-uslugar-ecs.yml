name: Backend - Reuse existing Task Definition (ECR→ECS)

on:
  push:
    branches: [ "main" ]
    paths:
      - "uslugar/backend/**"
      - ".github/workflows/backend-uslugar-ecs.yml"

env:
  AWS_REGION: eu-north-1
  ECR_REPO_BACKEND: uslugar
  ECS_CLUSTER: apps-cluster
  ECS_SERVICE: uslugar-service-2gk1f1mv
  CONTAINER_NAME: uslugar
  # 🔽 subneti/SG za one-off Fargate task koji će pokrenuti migracije
  # koristi javne subnete (radi pull-a iz ECR) ili privatne s NAT-om
  MIGRATE_SUBNETS: subnet-0a00f97768705bbcf,subnet-0546fb6cc0ad2cc37
  MIGRATE_SG: sg-084c1e49c9c77aff1

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: write   # treba za opcionalni auto-commit migracija

    steps:
      - uses: actions/checkout@v4

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - id: ecr-login
        uses: aws-actions/amazon-ecr-login@v2

      # 🔑 Ako nema package-lock.json, generiraj ga (Dockerfile koristi npm ci)
      - name: Generate package-lock.json (backend)
        working-directory: uslugar/backend
        run: |
          if [ ! -f package-lock.json ]; then
            echo "No package-lock.json found, generating..."
            npm i --package-lock-only
          fi
          head -n 20 package-lock.json || true

      # jq nam treba za čitanje JSON secreta
      - name: Install jq (for Secrets Manager parsing)
        run: sudo apt-get update && sudo apt-get install -y jq

      # ✅ Učitaj DATABASE_URL iz Secrets Managera (radi i za plain string i za JSON secret)
      #    Ovaj korak samo služi da prisma get-config/migrate imaju varijablu dostupnu u envu tijekom joba.
      - name: Load DATABASE_URL from Secrets Manager (for Prisma get-config)
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
          DB_SECRET_ARN: ${{ secrets.DB_SECRET_ARN }}
        run: |
          set -euo pipefail

          if [ -z "${DB_SECRET_ARN:-}" ]; then
            echo "ERROR: DB_SECRET_ARN is empty (GitHub secret nije postavljen ili nije proslijeđen u step)."
            exit 2
          fi

          RAW=$(aws secretsmanager get-secret-value \
                  --region "$AWS_REGION" \
                  --secret-id "$DB_SECRET_ARN" \
                  --query SecretString --output text)

          # Ako je JSON: pokušaj naći DATABASE_URL / database_url / url; inače tretiraj kao plain string
          if echo "$RAW" | jq -e . >/dev/null 2>&1; then
            DATABASE_URL=$(printf %s "$RAW" | jq -r '.DATABASE_URL // .database_url // .url')
          else
            DATABASE_URL="$RAW"
          fi

          if [ -z "${DATABASE_URL:-}" ] || [ "${DATABASE_URL}" = "null" ]; then
            echo "ERROR: DATABASE_URL nije pronađen u secretu."
            exit 3
          fi

          echo "::add-mask::${DATABASE_URL}"
          echo "DATABASE_URL=${DATABASE_URL}" >> "$GITHUB_ENV"
          echo "DATABASE_URL loaded."

      # 🧱 GENERIRAJ MIGRACIJE IZ schema.prisma – BEZ DB-a (create-only)
      - name: Create initial migration (create-only)
        working-directory: uslugar/backend
        run: |
          npx --yes prisma migrate dev --create-only --name init --schema=prisma/schema.prisma
          ls -la prisma/migrations || true

      # 📝 (opcionalno) Commitaj generirane migracije natrag u repo
      - name: Commit generated migrations
        working-directory: uslugar/backend
        run: |
          if [ -d prisma/migrations ] && [ -n "$(ls -A prisma/migrations || true)" ]; then
            git config user.name  "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add prisma/migrations prisma/migration_lock.toml || true
            git commit -m "chore(prisma): add/update migrations (CI create-only)" || echo "Nothing to commit"
            git push || echo "No push (e.g., workflow on PR)"
          fi

      - name: Build & Push image
        env:
          ECR_REGISTRY: ${{ steps.ecr-login.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -f uslugar/backend/Dockerfile.prod \
            -t $ECR_REGISTRY/${{ env.ECR_REPO_BACKEND }}:$IMAGE_TAG uslugar/backend
          docker push $ECR_REGISTRY/${{ env.ECR_REPO_BACKEND }}:$IMAGE_TAG
          echo "IMAGE_URI=$ECR_REGISTRY/${{ env.ECR_REPO_BACKEND }}:$IMAGE_TAG" >> $GITHUB_ENV

      - name: Read current Task Definition
        run: |
          TD_ARN=$(aws ecs describe-services \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --services "${{ env.ECS_SERVICE }}" \
            --query "services[0].taskDefinition" --output text)
          echo "Using task definition: $TD_ARN"
          aws ecs describe-task-definition --task-definition "$TD_ARN" \
            --query "taskDefinition" > td.json

          # Ukloni polja koja se ne smiju slati u register-task-definition
          jq 'del(
            .status,
            .requiresAttributes,
            .compatibilities,
            .revision,
            .registeredAt,
            .registeredBy,
            .deregisteredAt,
            .taskDefinitionArn,
            .tags,
            .inferenceAccelerators
          )' td.json > td_clean.json

      - name: Replace image in TD (+ ensure DATABASE_URL secret)
        env:
          DB_SECRET_ARN: ${{ secrets.DB_SECRET_ARN }}
        run: |
          # 1) zamijeni image za ciljani container
          jq --arg NAME "${{ env.CONTAINER_NAME }}" --arg IMG "${IMAGE_URI}" '
            .containerDefinitions = (.containerDefinitions | map(
              if .name == $NAME then .image = $IMG | . else . end
            ))
          ' td_clean.json > td_tmp.json

          # 2) osiguraj DATABASE_URL secret (valueFrom = ARN iz Secrets Managera)
          jq --arg NAME "${{ env.CONTAINER_NAME }}" --arg ARN "${DB_SECRET_ARN}" '
            .containerDefinitions = (.containerDefinitions | map(
              if .name == $NAME then
                .secrets = (
                  (.secrets // [])
                  | map(select(.name != "DATABASE_URL"))
                  + [{name:"DATABASE_URL", valueFrom:$ARN}]
                )
              else . end
            ))
          ' td_tmp.json > td_new.json

          echo "New image & DATABASE_URL secret ensured for '${{ env.CONTAINER_NAME }}'."

      - name: Register new TD revision
        run: |
          NEW_TD_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://td_new.json \
            --query "taskDefinition.taskDefinitionArn" --output text)
          echo "NEW_TD_ARN=$NEW_TD_ARN" >> $GITHUB_ENV
          echo "Registered: $NEW_TD_ARN"

      - name: Update service to new TD
        run: |
          aws ecs update-service \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --service "${{ env.ECS_SERVICE }}" \
            --task-definition "${NEW_TD_ARN}" \
            --query "service.taskDefinition" --output text

      # ✅ POST-DEPLOY: One-off Fargate task koji PRIMIJENI migracije na RDS (stvara tablice) 
      - name: Run Prisma migrate (one-off task)
        env:
          SUBNETS: ${{ env.MIGRATE_SUBNETS }}   # npr. javni sub-netovi zbog ECR pull-a
          SECGRP:  ${{ env.MIGRATE_SG }}        # SG s egress 443
          ASSIGN_PUBLIC_IP: ENABLED
        run: |
          set -euo pipefail
          echo "Running prisma migrate deploy on TD: ${NEW_TD_ARN}"

          # Overrides JSON: pokrećemo migrate u 'uslugar' containeru
          cat > overrides.json <<'JSON'
          {
            "containerOverrides": [
              {
                "name": "uslugar",
                "command": ["sh","-lc","npx --yes prisma migrate deploy --schema=prisma/schema.prisma && npx --yes prisma migrate status --schema=prisma/schema.prisma"],
                "environment": [
                  { "name": "PRISMA_OPENSSL_VERSION", "value": "3.0.x" }
                ]
              },
              { "name": "nginx-proxy", "command": ["sh","-lc","tail -f /dev/null"] }
            ]
          }
          JSON

          TASK_ARN=$(aws ecs run-task \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --launch-type FARGATE \
            --task-definition "${NEW_TD_ARN}" \
            --network-configuration "awsvpcConfiguration={subnets=[$SUBNETS],securityGroups=[$SECGRP],assignPublicIp=${ASSIGN_PUBLIC_IP}}" \
            --overrides file://overrides.json \
            --region "${{ env.AWS_REGION }}" \
            --query "tasks[0].taskArn" --output text)

          echo "Started migrate task: $TASK_ARN"
          aws ecs wait tasks-stopped --cluster "${{ env.ECS_CLUSTER }}" --tasks "$TASK_ARN" --region "${{ env.AWS_REGION }}"

          echo "---- Task stoppedReason ----"
          aws ecs describe-tasks --cluster "${{ env.ECS_CLUSTER }}" --tasks "$TASK_ARN" --region "${{ env.AWS_REGION }}" \
            --query "tasks[0].stoppedReason" --output text || true

          echo "---- Container breakdown ----"
          aws ecs describe-tasks --cluster "${{ env.ECS_CLUSTER }}" --tasks "$TASK_ARN" --region "${{ env.AWS_REGION }}" \
            --query "tasks[0].containers[].{name:name,lastStatus:lastStatus,exitCode:exitCode,reason:reason}" --output table || true

          EXIT_CODE=$(aws ecs describe-tasks \
            --cluster "${{ env.ECS_CLUSTER }}" --tasks "$TASK_ARN" --region "${{ env.AWS_REGION }}" \
            --query "tasks[0].containers[?name=='${{ env.CONTAINER_NAME }}'].exitCode | [0]" --output text)

          echo "Migrate task exit code: ${EXIT_CODE}"

          LOG_GROUP=$(aws ecs describe-task-definition --task-definition "${NEW_TD_ARN}" \
            --query "taskDefinition.containerDefinitions[?name=='${{ env.CONTAINER_NAME }}'].logConfiguration.options.\"awslogs-group\" | [0]" --output text)
          LOG_PREFIX=$(aws ecs describe-task-definition --task-definition "${NEW_TD_ARN}" \
            --query "taskDefinition.containerDefinitions[?name=='${{ env.CONTAINER_NAME }}'].logConfiguration.options.\"awslogs-stream-prefix\" | [0]" --output text)
          TASK_ID=${TASK_ARN##*/}

          if [ -z "$EXIT_CODE" ] || [ "$EXIT_CODE" = "None" ] || [ "$EXIT_CODE" != "0" ]; then
            echo "Prisma migrate failed (exit=${EXIT_CODE:-unset})"
            if [ -n "$LOG_GROUP" ] && [ -n "$LOG_PREFIX" ] && [ "$LOG_GROUP" != "None" ] && [ "$LOG_PREFIX" != "None" ]; then
              aws logs tail "$LOG_GROUP" --log-stream-names "$LOG_PREFIX/${{ env.CONTAINER_NAME }}/$TASK_ID" --since 30m --region "${{ env.AWS_REGION }}" || \
              aws logs tail "$LOG_GROUP" --since 30m --region "${{ env.AWS_REGION }}" || true
            fi
            exit 1
          fi

          echo "Prisma migrate finished successfully."
