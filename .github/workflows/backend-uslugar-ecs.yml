name: Backend - Reuse existing Task Definition (ECRâ†’ECS)

on:
  workflow_dispatch:
  push:
    branches: ["main"]
    paths:
      - "uslugar/backend/**"
      - ".github/workflows/backend-uslugar-ecs.yml"

env:
  AWS_REGION: eu-north-1
  ECR_REPO_BACKEND: uslugar
  ECR_REPO_PRISMA: uslugar-prisma-tasks
  ECS_CLUSTER: apps-cluster
  ECS_SERVICE: uslugar-service-2gk1f1mv
  CONTAINER_NAME: uslugar

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: write

    steps:
      - uses: actions/checkout@v4

      # (opcionalno) pinaj Node 20 da npm radi sigurno
      - uses: actions/setup-node@v4
        with:
          node-version: 20

      # ðŸ” Osiguraj package-lock.json prije docker builda
      - name: Ensure package-lock.json (backend)
        working-directory: uslugar/backend
        run: |
          if [ ! -f package-lock.json ]; then
            npm i --package-lock-only
          fi
          ls -l package-lock.json || true

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - id: ecr-login
        uses: aws-actions/amazon-ecr-login@v2

      # Ako nemaÅ¡ CreateRepository dozvolu, ovo samo upozori umjesto da puca
      - name: Ensure ECR repos (describe or warn)
        run: |
          set -e
          for NAME in "${{ env.ECR_REPO_BACKEND }}" "${{ env.ECR_REPO_PRISMA }}"; do
            if ! aws ecr describe-repositories --repository-names "$NAME" >/dev/null 2>&1; then
              echo "::warning::ECR repo '$NAME' ne postoji ili rola nema ecr:CreateRepository. Kreiraj ga ruÄno u eu-north-1."
            fi
          done

      # âœ… OVO JE TVOJ TRAÅ½ENI KORAK â€” povuci SHA/:latest ili izgradi lokalno i pushaj :latest
      - name: Build & Push app image (uses prisma image by SHA or builds locally)
        env:
          ECR_REGISTRY: ${{ steps.ecr-login.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          set -euo pipefail
          PRISMA_SHA="$ECR_REGISTRY/${{ env.ECR_REPO_PRISMA }}:${{ github.sha }}"
          PRISMA_LATEST="$ECR_REGISTRY/${{ env.ECR_REPO_PRISMA }}:latest"

          # 1) probaj pull po SHA
          if docker pull "$PRISMA_SHA" ; then
            USE_PRISMA_IMAGE="$PRISMA_SHA"

          # 2) probaj pull :latest
          elif docker pull "$PRISMA_LATEST" ; then
            USE_PRISMA_IMAGE="$PRISMA_LATEST"

          # 3) nema slike â†’ izgradi lokalno i (po Å¾elji) pushaj :latest
          else
            echo "Prisma image not found; building locallyâ€¦"
            docker build -f uslugar/backend/Dockerfile.prisma \
              -t "$PRISMA_LATEST" \
              uslugar/backend
            # push latest da postoji fallback iduÄ‡i put (ako rola ima pravo)
            docker push "$PRISMA_LATEST" || true
            USE_PRISMA_IMAGE="$PRISMA_LATEST"
          fi

          # Izgradi backend s definiranim PRISMA_IMAGE (bez cache za Prisma fix)
          docker build --no-cache -f uslugar/backend/Dockerfile.prod \
            --build-arg PRISMA_IMAGE="$USE_PRISMA_IMAGE" \
            -t $ECR_REGISTRY/${{ env.ECR_REPO_BACKEND }}:$IMAGE_TAG \
            uslugar/backend

          docker push $ECR_REGISTRY/${{ env.ECR_REPO_BACKEND }}:$IMAGE_TAG
          echo "IMAGE_URI=$ECR_REGISTRY/${{ env.ECR_REPO_BACKEND }}:$IMAGE_TAG" >> $GITHUB_ENV

      - name: Read current Task Definition
        run: |
          TD_ARN=$(aws ecs describe-services \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --services "${{ env.ECS_SERVICE }}" \
            --query "services[0].taskDefinition" --output text)
          aws ecs describe-task-definition --task-definition "$TD_ARN" \
            --query "taskDefinition" --output json > td.json

          jq 'del(.status,.requiresAttributes,.compatibilities,.revision,.registeredAt,.registeredBy,.deregisteredAt,.taskDefinitionArn,.tags,.inferenceAccelerators)' td.json > td_clean.json
          
          echo "Current executionRoleArn:"
          jq '.executionRoleArn // "NOT SET"' td_clean.json
          
          echo "Current taskRoleArn:"
          jq '.taskRoleArn // "NOT SET"' td_clean.json

      - name: Find Stripe secrets in Secrets Manager
        run: |
          echo "Listing all secrets to find Stripe secrets..."
          aws secretsmanager list-secrets --region eu-north-1 --query "SecretList[?contains(Name, 'stripe')].{Name:Name, ARN:ARN}" --output table || echo "Could not list secrets"
          
          # Try to find secrets by searching for names containing "stripe"
          echo ""
          echo "Searching for Stripe secrets..."
          
          # List all secrets and find ones with "stripe" in the name
          ALL_SECRETS=$(aws secretsmanager list-secrets --region eu-north-1 --output json 2>/dev/null || echo "{}")
          
          # Find secret key (contains "secret-key" or "secret_key")
          SECRET_KEY_ARN=$(echo "$ALL_SECRETS" | jq -r '.SecretList[] | select(.Name | contains("stripe") and (contains("secret-key") or contains("secret_key"))) | .ARN' | head -1)
          
          # Find publishable key (contains "publishable-key" or "publishable_key")
          PUBLISHABLE_KEY_ARN=$(echo "$ALL_SECRETS" | jq -r '.SecretList[] | select(.Name | contains("stripe") and (contains("publishable-key") or contains("publishable_key"))) | .ARN' | head -1)
          
          # If not found, try alternative names
          if [ -z "$SECRET_KEY_ARN" ] || [ "$SECRET_KEY_ARN" == "null" ]; then
            echo "âš ï¸  Secret key not found by pattern, trying alternative search..."
            SECRET_KEY_ARN=$(echo "$ALL_SECRETS" | jq -r '.SecretList[] | select(.Name | contains("stripe") and (contains("secret") or contains("sk_"))) | .ARN' | head -1)
          fi
          
          if [ -z "$PUBLISHABLE_KEY_ARN" ] || [ "$PUBLISHABLE_KEY_ARN" == "null" ]; then
            echo "âš ï¸  Publishable key not found by pattern, trying alternative search..."
            PUBLISHABLE_KEY_ARN=$(echo "$ALL_SECRETS" | jq -r '.SecretList[] | select(.Name | contains("stripe") and (contains("publishable") or contains("pk_"))) | .ARN' | head -1)
          fi
          
          # If still not found, use name-based approach (AWS ECS supports secret names directly)
          if [ -z "$SECRET_KEY_ARN" ] || [ "$SECRET_KEY_ARN" == "null" ]; then
            echo "âš ï¸  Secret key ARN not found, will use secret name instead"
            SECRET_KEY_NAME=$(echo "$ALL_SECRETS" | jq -r '.SecretList[] | select(.Name | contains("stripe") and (contains("secret") or contains("sk_"))) | .Name' | head -1)
            if [ -n "$SECRET_KEY_NAME" ] && [ "$SECRET_KEY_NAME" != "null" ]; then
              echo "âœ… Will use secret name: $SECRET_KEY_NAME"
              echo "STRIPE_SECRET_KEY_NAME=$SECRET_KEY_NAME" >> $GITHUB_ENV
              echo "STRIPE_SECRET_KEY_ARN=" >> $GITHUB_ENV
            else
              echo "âŒ Stripe Secret Key not found!"
              exit 1
            fi
          else
            echo "âœ… Found Stripe Secret Key ARN: $SECRET_KEY_ARN"
            echo "STRIPE_SECRET_KEY_ARN=$SECRET_KEY_ARN" >> $GITHUB_ENV
            echo "STRIPE_SECRET_KEY_NAME=" >> $GITHUB_ENV
          fi
          
          if [ -z "$PUBLISHABLE_KEY_ARN" ] || [ "$PUBLISHABLE_KEY_ARN" == "null" ]; then
            echo "âš ï¸  Publishable key ARN not found, will use secret name instead"
            PUBLISHABLE_KEY_NAME=$(echo "$ALL_SECRETS" | jq -r '.SecretList[] | select(.Name | contains("stripe") and (contains("publishable") or contains("pk_"))) | .Name' | head -1)
            if [ -n "$PUBLISHABLE_KEY_NAME" ] && [ "$PUBLISHABLE_KEY_NAME" != "null" ]; then
              echo "âœ… Will use secret name: $PUBLISHABLE_KEY_NAME"
              echo "STRIPE_PUBLISHABLE_KEY_NAME=$PUBLISHABLE_KEY_NAME" >> $GITHUB_ENV
              echo "STRIPE_PUBLISHABLE_KEY_ARN=" >> $GITHUB_ENV
            else
              echo "âŒ Stripe Publishable Key not found!"
              exit 1
            fi
          else
            echo "âœ… Found Stripe Publishable Key ARN: $PUBLISHABLE_KEY_ARN"
            echo "STRIPE_PUBLISHABLE_KEY_ARN=$PUBLISHABLE_KEY_ARN" >> $GITHUB_ENV
            echo "STRIPE_PUBLISHABLE_KEY_NAME=" >> $GITHUB_ENV
          fi

      - name: Replace image in TD and add environment variables
        run: |
          echo "Current container secrets before update:"
          jq '.containerDefinitions[] | select(.name == "${{ env.CONTAINER_NAME }}") | .secrets // []' td_clean.json || echo "No secrets found"
          
          # Use ARN if available, otherwise use secret name
          if [ -n "${STRIPE_SECRET_KEY_ARN}" ]; then
            SECRET_REF="${STRIPE_SECRET_KEY_ARN}"
            echo "Using Stripe Secret Key ARN: ${SECRET_REF}"
          else
            SECRET_REF="${STRIPE_SECRET_KEY_NAME}"
            echo "Using Stripe Secret Key Name: ${SECRET_REF}"
          fi
          
          if [ -n "${STRIPE_PUBLISHABLE_KEY_ARN}" ]; then
            PUBLISHABLE_REF="${STRIPE_PUBLISHABLE_KEY_ARN}"
            echo "Using Stripe Publishable Key ARN: ${PUBLISHABLE_REF}"
          else
            PUBLISHABLE_REF="${STRIPE_PUBLISHABLE_KEY_NAME}"
            echo "Using Stripe Publishable Key Name: ${PUBLISHABLE_REF}"
          fi
          
          jq --arg NAME "${{ env.CONTAINER_NAME }}" \
             --arg IMG "${IMAGE_URI}" \
             --arg SECRET_REF "${SECRET_REF}" \
             --arg PUBLISHABLE_REF "${PUBLISHABLE_REF}" '
            # Ensure executionRoleArn exists (required for secrets from Secrets Manager)
            if (.executionRoleArn == null or .executionRoleArn == "") then
              .executionRoleArn = "arn:aws:iam::666203386231:role/ecsTaskExecutionRole"
            else . end |
            # Ensure taskRoleArn exists (for S3 access)
            if (.taskRoleArn == null or .taskRoleArn == "") then
              .taskRoleArn = "arn:aws:iam::666203386231:role/ecsTaskRole"
            else . end |
            .containerDefinitions = (.containerDefinitions | map(
              if .name == $NAME then 
                .image = $IMG |
                .environment = ((.environment // []) + [
                  {
                    "name": "CORS_ORIGINS",
                    "value": "https://uslugar.oriph.io,http://localhost:5173,http://localhost:3000"
                  },
                  {
                    "name": "SUDREG_CLIENT_ID",
                    "value": "UcfrGwvRv3uGkqvYnUMxIA.."
                  },
                  {
                    "name": "SUDREG_CLIENT_SECRET",
                    "value": "-TX-7q_UfffSEaRmGIP4bA.."
                  },
                  {
                    "name": "AWS_S3_BUCKET_NAME",
                    "value": "uslugar-invoices"
                  },
                  {
                    "name": "AWS_REGION",
                    "value": "eu-north-1"
                  }
                ]) |
                # Remove existing Stripe secrets and add new ones (plaintext secrets, no ::KEY:: suffix)
                # Use ARN if available, otherwise use secret name (AWS ECS supports both)
                .secrets = ((.secrets // []) | 
                  map(select(.name != "STRIPE_SECRET_KEY" and .name != "STRIPE_PUBLISHABLE_KEY")) +
                  [
                    {
                      "name": "STRIPE_SECRET_KEY",
                      "valueFrom": $SECRET_REF
                    },
                    {
                      "name": "STRIPE_PUBLISHABLE_KEY",
                      "valueFrom": $PUBLISHABLE_REF
                    }
                  ])
              else . end
            ))
          ' td_clean.json > td_new.json
          
          echo "Container secrets after update:"
          jq '.containerDefinitions[] | select(.name == "${{ env.CONTAINER_NAME }}") | .secrets' td_new.json || echo "No secrets found"

      - name: Register new TD revision
        run: |
          NEW_TD_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://td_new.json \
            --query "taskDefinition.taskDefinitionArn" --output text)
          echo "NEW_TD_ARN=$NEW_TD_ARN" >> $GITHUB_ENV
          echo "Registered: $NEW_TD_ARN"

      - name: Update service to new TD
        run: |
          aws ecs update-service \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --service "${{ env.ECS_SERVICE }}" \
            --task-definition "${NEW_TD_ARN}" \
            --query "service.taskDefinition" --output text
