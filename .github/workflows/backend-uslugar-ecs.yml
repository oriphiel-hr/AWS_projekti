name: Backend - Reuse existing Task Definition (ECR‚ÜíECS)

on:
  workflow_dispatch:
  push:
    branches: ["main"]
    paths:
      - "uslugar/backend/**"
      - ".github/workflows/backend-uslugar-ecs.yml"

env:
  AWS_REGION: eu-north-1
  ECR_REPO_BACKEND: uslugar
  ECR_REPO_PRISMA: uslugar-prisma-tasks
  ECS_CLUSTER: apps-cluster
  ECS_SERVICE: uslugar-service-2gk1f1mv
  CONTAINER_NAME: uslugar

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: write

    steps:
      - uses: actions/checkout@v4

      # (opcionalno) pinaj Node 20 da npm radi sigurno
      - uses: actions/setup-node@v4
        with:
          node-version: 20

      # üîê Osiguraj package-lock.json prije docker builda
      - name: Ensure package-lock.json (backend)
        working-directory: uslugar/backend
        run: |
          if [ ! -f package-lock.json ]; then
            npm i --package-lock-only
          fi
          ls -l package-lock.json || true

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - id: ecr-login
        uses: aws-actions/amazon-ecr-login@v2

      # Ako nema≈° CreateRepository dozvolu, ovo samo upozori umjesto da puca
      - name: Ensure ECR repos (describe or warn)
        run: |
          set -e
          for NAME in "${{ env.ECR_REPO_BACKEND }}" "${{ env.ECR_REPO_PRISMA }}"; do
            if ! aws ecr describe-repositories --repository-names "$NAME" >/dev/null 2>&1; then
              echo "::warning::ECR repo '$NAME' ne postoji ili rola nema ecr:CreateRepository. Kreiraj ga ruƒçno u eu-north-1."
            fi
          done

      # ‚úÖ OVO JE TVOJ TRA≈ΩENI KORAK ‚Äî povuci SHA/:latest ili izgradi lokalno i pushaj :latest
      - name: Build & Push app image (uses prisma image by SHA or builds locally)
        env:
          ECR_REGISTRY: ${{ steps.ecr-login.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          set -euo pipefail
          PRISMA_SHA="$ECR_REGISTRY/${{ env.ECR_REPO_PRISMA }}:${{ github.sha }}"
          PRISMA_LATEST="$ECR_REGISTRY/${{ env.ECR_REPO_PRISMA }}:latest"

          # 1) probaj pull po SHA
          if docker pull "$PRISMA_SHA" ; then
            USE_PRISMA_IMAGE="$PRISMA_SHA"

          # 2) probaj pull :latest
          elif docker pull "$PRISMA_LATEST" ; then
            USE_PRISMA_IMAGE="$PRISMA_LATEST"

          # 3) nema slike ‚Üí izgradi lokalno i (po ≈æelji) pushaj :latest
          else
            echo "Prisma image not found; building locally‚Ä¶"
            docker build -f uslugar/backend/Dockerfile.prisma \
              -t "$PRISMA_LATEST" \
              uslugar/backend
            # push latest da postoji fallback iduƒái put (ako rola ima pravo)
            docker push "$PRISMA_LATEST" || true
            USE_PRISMA_IMAGE="$PRISMA_LATEST"
          fi

          # Izgradi backend s definiranim PRISMA_IMAGE (bez cache za Prisma fix)
          docker build --no-cache -f uslugar/backend/Dockerfile.prod \
            --build-arg PRISMA_IMAGE="$USE_PRISMA_IMAGE" \
            -t $ECR_REGISTRY/${{ env.ECR_REPO_BACKEND }}:$IMAGE_TAG \
            uslugar/backend

          docker push $ECR_REGISTRY/${{ env.ECR_REPO_BACKEND }}:$IMAGE_TAG
          echo "IMAGE_URI=$ECR_REGISTRY/${{ env.ECR_REPO_BACKEND }}:$IMAGE_TAG" >> $GITHUB_ENV

      - name: Read current Task Definition
        run: |
          TD_ARN=$(aws ecs describe-services \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --services "${{ env.ECS_SERVICE }}" \
            --query "services[0].taskDefinition" --output text)
          aws ecs describe-task-definition --task-definition "$TD_ARN" \
            --query "taskDefinition" --output json > td.json

          jq 'del(.status,.requiresAttributes,.compatibilities,.revision,.registeredAt,.registeredBy,.deregisteredAt,.taskDefinitionArn,.tags,.inferenceAccelerators)' td.json > td_clean.json
          
          echo "Current executionRoleArn:"
          jq '.executionRoleArn // "NOT SET"' td_clean.json
          
          echo "Current taskRoleArn:"
          jq '.taskRoleArn // "NOT SET"' td_clean.json

      - name: Set Stripe secret references
        run: |
          # Use full ARN with suffix (as documented in STRIPE-MANUAL-SETUP.md)
          # AWS ECS requires the full ARN for plaintext secrets
          # Update these ARNs if your secrets have different suffixes
          
          # Full ARNs with suffixes (update if different)
          SECRET_KEY_ARN="arn:aws:secretsmanager:eu-north-1:666203386231:secret:uslugar/stripe-secret-key-jKdcdD"
          PUBLISHABLE_KEY_ARN="arn:aws:secretsmanager:eu-north-1:666203386231:secret:uslugar/stripe-publishable-key-37rvJI"
          
          echo "Using Stripe Secret Key ARN: $SECRET_KEY_ARN"
          echo "Using Stripe Publishable Key ARN: $PUBLISHABLE_KEY_ARN"
          echo ""
          echo "Note: If these ARNs don't match your secrets, update them in this workflow file."
          echo "The actual secret ARNs can be found in AWS Secrets Manager console."
          
          echo "STRIPE_SECRET_KEY_REF=$SECRET_KEY_ARN" >> $GITHUB_ENV
          echo "STRIPE_PUBLISHABLE_KEY_REF=$PUBLISHABLE_KEY_ARN" >> $GITHUB_ENV

      - name: Replace image in TD and add environment variables
        run: |
          echo "Current container secrets before update:"
          jq '.containerDefinitions[] | select(.name == "${{ env.CONTAINER_NAME }}") | .secrets // []' td_clean.json || echo "No secrets found"
          
          echo "Using Stripe Secret Key: ${STRIPE_SECRET_KEY_REF}"
          echo "Using Stripe Publishable Key: ${STRIPE_PUBLISHABLE_KEY_REF}"
          
          jq --arg NAME "${{ env.CONTAINER_NAME }}" \
             --arg IMG "${IMAGE_URI}" \
             --arg SECRET_REF "${STRIPE_SECRET_KEY_REF}" \
             --arg PUBLISHABLE_REF "${STRIPE_PUBLISHABLE_KEY_REF}" '
            # Ensure executionRoleArn exists (required for secrets from Secrets Manager)
            if (.executionRoleArn == null or .executionRoleArn == "") then
              .executionRoleArn = "arn:aws:iam::666203386231:role/ecsTaskExecutionRole"
            else . end |
            # Ensure taskRoleArn exists (for S3 access)
            if (.taskRoleArn == null or .taskRoleArn == "") then
              .taskRoleArn = "arn:aws:iam::666203386231:role/ecsTaskRole"
            else . end |
            .containerDefinitions = (.containerDefinitions | map(
              if .name == $NAME then 
                .image = $IMG |
                .environment = ((.environment // []) + [
                  {
                    "name": "CORS_ORIGINS",
                    "value": "https://uslugar.oriph.io,http://localhost:5173,http://localhost:3000"
                  },
                  {
                    "name": "SUDREG_CLIENT_ID",
                    "value": "UcfrGwvRv3uGkqvYnUMxIA.."
                  },
                  {
                    "name": "SUDREG_CLIENT_SECRET",
                    "value": "-TX-7q_UfffSEaRmGIP4bA.."
                  },
                  {
                    "name": "AWS_S3_BUCKET_NAME",
                    "value": "uslugar-invoices"
                  },
                  {
                    "name": "AWS_REGION",
                    "value": "eu-north-1"
                  }
                ]) |
                # Remove existing Stripe secrets and add new ones (plaintext secrets, no ::KEY:: suffix)
                # Use ARN if available, otherwise use secret name (AWS ECS supports both)
                .secrets = ((.secrets // []) | 
                  map(select(.name != "STRIPE_SECRET_KEY" and .name != "STRIPE_PUBLISHABLE_KEY")) +
                  [
                    {
                      "name": "STRIPE_SECRET_KEY",
                      "valueFrom": $SECRET_REF
                    },
                    {
                      "name": "STRIPE_PUBLISHABLE_KEY",
                      "valueFrom": $PUBLISHABLE_REF
                    }
                  ])
              else . end
            ))
          ' td_clean.json > td_new.json
          
          echo "Container secrets after update:"
          jq '.containerDefinitions[] | select(.name == "${{ env.CONTAINER_NAME }}") | .secrets' td_new.json || echo "No secrets found"

      - name: Register new TD revision
        run: |
          NEW_TD_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://td_new.json \
            --query "taskDefinition.taskDefinitionArn" --output text)
          echo "NEW_TD_ARN=$NEW_TD_ARN" >> $GITHUB_ENV
          echo "Registered: $NEW_TD_ARN"

      - name: Update service to new TD
        run: |
          echo "Updating ECS service to use new Task Definition..."
          aws ecs update-service \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --service "${{ env.ECS_SERVICE }}" \
            --task-definition "${NEW_TD_ARN}" \
            --force-new-deployment \
            --query "service.taskDefinition" --output text
          
          echo ""
          echo "‚úÖ Service update initiated. New tasks will be deployed with Stripe secrets."
          echo "‚è≥ Waiting for deployment to stabilize (this may take 2-3 minutes)..."
          
          # Wait for service to stabilize (with timeout)
          echo "Monitoring deployment status..."
          aws ecs wait services-stable \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --services "${{ env.ECS_SERVICE }}" \
            --region "${{ env.AWS_REGION }}" || echo "‚ö†Ô∏è  Deployment may still be in progress"
          
          echo ""
          echo "‚úÖ Deployment completed!"
          echo ""
          echo "To verify Stripe is working:"
          echo "  - Check CloudWatch logs: aws logs tail /ecs/uslugar --follow --region eu-north-1 --filter-pattern 'STRIPE'"
          echo "  - Look for: '[PAYMENTS] Stripe initialized successfully'"
          echo "  - Test admin payments endpoint: /api/payments/admin/sessions"
          
          # Show current deployment status
          echo ""
          echo "Current deployment status:"
          aws ecs describe-services \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --services "${{ env.ECS_SERVICE }}" \
            --region "${{ env.AWS_REGION }}" \
            --query "services[0].deployments[0].{Status:status,TaskDefinition:taskDefinition,RunningCount:runningCount,DesiredCount:desiredCount}" \
            --output table || echo "Could not fetch deployment status"
