name: Prisma - Build/Push & Migrate (ECR→ECS)

on:
  workflow_dispatch:
  push:
    branches: ["main"]
    paths:
      - "uslugar/backend/prisma/**"
      - "uslugar/backend/Dockerfile.prisma"
      - ".github/workflows/prisma-uslugar.yml"

env:
  AWS_REGION: eu-north-1
  ECR_REPO_PRISMA: uslugar-prisma-tasks
  ECS_CLUSTER: apps-cluster
  MIGRATE_SUBNETS: subnet-0a00f97768705bbcf,subnet-0546fb6cc0ad2cc37
  MIGRATE_SG: sg-084c1e49c9c77aff1

jobs:
  prisma:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - uses: actions/checkout@v4

      # (opcionalno, ali preporučeno) Node 20
      - uses: actions/setup-node@v4
        with:
          node-version: 20

      # Osiguraj package-lock.json prije docker builda
      - name: Ensure package-lock.json (backend)
        working-directory: uslugar/backend
        run: |
          if [ ! -f package-lock.json ]; then
            npm i --package-lock-only
          fi
          ls -l package-lock.json || true

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - id: ecr-login
        uses: aws-actions/amazon-ecr-login@v2

      - name: Ensure ECR repo exists
        run: |
          aws ecr describe-repositories --repository-names "${{ env.ECR_REPO_PRISMA }}" >/dev/null 2>&1 || \
          aws ecr create-repository --repository-name "${{ env.ECR_REPO_PRISMA }}" >/dev/null

      - name: Build & Push prisma-tasks image (SHA + latest)
        env:
          ECR_REGISTRY: ${{ steps.ecr-login.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -f uslugar/backend/Dockerfile.prisma \
            -t $ECR_REGISTRY/${{ env.ECR_REPO_PRISMA }}:$IMAGE_TAG \
            -t $ECR_REGISTRY/${{ env.ECR_REPO_PRISMA }}:latest \
            uslugar/backend

          docker push $ECR_REGISTRY/${{ env.ECR_REPO_PRISMA }}:$IMAGE_TAG
          docker push $ECR_REGISTRY/${{ env.ECR_REPO_PRISMA }}:latest

          echo "PRISMA_IMAGE_URI=$ECR_REGISTRY/${{ env.ECR_REPO_PRISMA }}:$IMAGE_TAG" >> $GITHUB_ENV

      # 🔄 koristi čist JSON + jq patch (bez riskantnog shell quoting-a)
      - name: Run Prisma migrate (one-off Fargate task)
        env:
          SUBNETS: ${{ env.MIGRATE_SUBNETS }}
          SECGRP:  ${{ env.MIGRATE_SG }}
          ASSIGN_PUBLIC_IP: ENABLED
          AWS_REGION: ${{ env.AWS_REGION }}
          DB_SECRET_ARN: ${{ secrets.DB_SECRET_ARN }}
          AWS_ECS_TASK_EXEC_ROLE_ARN: ${{ secrets.AWS_ECS_TASK_EXEC_ROLE_ARN }}
          AWS_ECS_TASK_ROLE_ARN: ${{ secrets.AWS_ECS_TASK_ROLE_ARN }}
        run: |
          set -euo pipefail
          echo "Using PRISMA_IMAGE_URI=${PRISMA_IMAGE_URI}"

          sudo apt-get update -y >/dev/null
          sudo apt-get install -y jq >/dev/null

          # 1) ČIST JSON ŠABLON (bez interpolacije varijabli)
          cat > prisma-td.json <<'JSON'
          {
            "family": "uslugar-prisma-oneoff",
            "networkMode": "awsvpc",
            "cpu": "256",
            "memory": "512",
            "requiresCompatibilities": ["FARGATE"],
            "containerDefinitions": [
              {
                "name": "prisma",
                "image": "REPLACE_IMAGE",
                "essential": true,
                "environment": [
                  { "name": "PRISMA_OPENSSL_VERSION", "value": "3.0.x" }
                ],
                "secrets": [
                  { "name": "DATABASE_URL", "valueFrom": "REPLACE_DB_ARN:DATABASE_URL::" }
                ],
                "logConfiguration": {
                  "logDriver": "awslogs",
                  "options": {
                    "awslogs-region": "REPLACE_REGION",
                    "awslogs-group": "/ecs/uslugar/prisma",
                    "awslogs-stream-prefix": "oneoff"
                  }
                ],
                "command": ["sh","-lc","npx prisma migrate deploy --schema=./prisma && npx prisma migrate status --schema=./prisma"]
              }
            ]
          }
          JSON

          # 2) UPIŠI VARIJABLE U JSON
          jq \
            --arg img    "$PRISMA_IMAGE_URI" \
            --arg region "$AWS_REGION" \
            --arg dbarn  "$DB_SECRET_ARN" \
            '
              .containerDefinitions[0].image = $img
              | .containerDefinitions[0].secrets[0].valueFrom = ($dbarn + ":DATABASE_URL::")
              | .containerDefinitions[0].logConfiguration.options["awslogs-region"] = $region
            ' prisma-td.json > prisma-td.tmp && mv prisma-td.tmp prisma-td.json

          # (opcionalno) Dodaj role samo ako su zadane
          if [ -n "${AWS_ECS_TASK_EXEC_ROLE_ARN:-}" ]; then
            jq --arg v "$AWS_ECS_TASK_EXEC_ROLE_ARN" '.executionRoleArn = $v' prisma-td.json > t && mv t prisma-td.json
          fi
          if [ -n "${AWS_ECS_TASK_ROLE_ARN:-}" ]; then
            jq --arg v "$AWS_ECS_TASK_ROLE_ARN" '.taskRoleArn = $v' prisma-td.json > t && mv t prisma-td.json
          fi

          echo "----- prisma-td.json -----"
          cat prisma-td.json
          echo "--------------------------"

          # 3) Register + run one-off
          TD_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://prisma-td.json \
            --query "taskDefinition.taskDefinitionArn" --output text)

          TASK_ARN=$(aws ecs run-task \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --launch-type FARGATE \
            --task-definition "$TD_ARN" \
            --network-configuration "awsvpcConfiguration={subnets=[${SUBNETS}],securityGroups=[${SECGRP}],assignPublicIp=${ASSIGN_PUBLIC_IP}}" \
            --query "tasks[0].taskArn" --output text)

          echo "Task: $TASK_ARN"
          aws ecs wait tasks-stopped --cluster "${{ env.ECS_CLUSTER }}" --tasks "$TASK_ARN"

          EXIT=$(aws ecs describe-tasks --cluster "${{ env.ECS_CLUSTER }}" --tasks "$TASK_ARN" \
            --query "tasks[0].containers[0].exitCode" --output text)
          echo "Exit code: $EXIT"
          test "$EXIT" = "0"
