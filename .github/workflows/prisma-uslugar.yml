name: Prisma - Build/Push & Migrate (ECR→ECS)

on:
  workflow_dispatch:
  push:
    branches: ["main"]
    paths:
      - "uslugar/backend/prisma/**"
      - "uslugar/backend/Dockerfile.prisma"
      - ".github/workflows/prisma-uslugar.yml"

env:
  AWS_REGION: eu-north-1
  ECR_REPO_PRISMA: uslugar-prisma-tasks
  ECS_CLUSTER: apps-cluster
  MIGRATE_SUBNETS: subnet-0a00f97768705bbcf,subnet-0546fb6cc0ad2cc37
  MIGRATE_SG: sg-084c1e49c9c77aff1

jobs:
  prisma:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20

      # Osiguraj package-lock.json prije docker builda
      - name: Ensure package-lock.json (backend)
        working-directory: uslugar/backend
        run: |
          if [ ! -f package-lock.json ]; then
            npm i --package-lock-only
          fi
          ls -l package-lock.json || true

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - id: ecr-login
        uses: aws-actions/amazon-ecr-login@v2

      - name: Ensure ECR repo exists
        run: |
          aws ecr describe-repositories --repository-names "${{ env.ECR_REPO_PRISMA }}" >/dev/null 2>&1 || \
          aws ecr create-repository --repository-name "${{ env.ECR_REPO_PRISMA }}" >/dev/null

      - name: Build & Push prisma-tasks image (SHA + latest)
        env:
          ECR_REGISTRY: ${{ steps.ecr-login.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -f uslugar/backend/Dockerfile.prisma \
            -t $ECR_REGISTRY/${{ env.ECR_REPO_PRISMA }}:$IMAGE_TAG \
            -t $ECR_REGISTRY/${{ env.ECR_REPO_PRISMA }}:latest \
            uslugar/backend

          docker push $ECR_REGISTRY/${{ env.ECR_REPO_PRISMA }}:$IMAGE_TAG
          docker push $ECR_REGISTRY/${{ env.ECR_REPO_PRISMA }}:latest

          echo "PRISMA_IMAGE_URI=$ECR_REGISTRY/${{ env.ECR_REPO_PRISMA }}:$IMAGE_TAG" >> $GITHUB_ENV

      - name: Run Prisma migrate (one-off Fargate task)
        env:
          SUBNETS: ${{ env.MIGRATE_SUBNETS }}
          SECGRP:  ${{ env.MIGRATE_SG }}
          ASSIGN_PUBLIC_IP: ENABLED
          AWS_REGION: ${{ env.AWS_REGION }}
          DB_SECRET_ARN: ${{ secrets.DB_SECRET_ARN }}
          AWS_ECS_TASK_EXEC_ROLE_ARN: ${{ secrets.AWS_ECS_TASK_EXEC_ROLE_ARN }}
          AWS_ECS_TASK_ROLE_ARN: ${{ secrets.AWS_ECS_TASK_ROLE_ARN }}
        run: |
          set -euo pipefail

          echo "Using PRISMA_IMAGE_URI=${PRISMA_IMAGE_URI}"

          # executionRoleArn je obavezan jer koristimo container secrets/ECR/logs
          if [ -z "${AWS_ECS_TASK_EXEC_ROLE_ARN:-}" ]; then
            echo "::error::AWS_ECS_TASK_EXEC_ROLE_ARN je obavezan kada koristiš container secrets. Dodaj ga u repo secrets."
            exit 1
          fi

          # (preporučeno) kreiraj log group ako ne postoji
          if ! aws logs describe-log-groups --log-group-name-prefix "/ecs/uslugar/prisma" \
               --query "logGroups[?logGroupName=='/ecs/uslugar/prisma'] | length(@)" --output text | grep -q "^1$"; then
            aws logs create-log-group --log-group-name "/ecs/uslugar/prisma" --region "${AWS_REGION}" || true
            aws logs put-retention-policy --log-group-name "/ecs/uslugar/prisma" --retention-in-days 30 || true
          fi

          # 1) Container JSON (eksplicitni schema path)
          CONTAINER=$(printf '{"name":"prisma","image":"%s","essential":true,"environment":[{"name":"PRISMA_OPENSSL_VERSION","value":"3.0.x"}],"secrets":[{"name":"DATABASE_URL","valueFrom":"%s:DATABASE_URL::"}],"logConfiguration":{"logDriver":"awslogs","options":{"awslogs-region":"%s","awslogs-group":"/ecs/uslugar/prisma","awslogs-stream-prefix":"oneoff"}},"command":["sh","-lc","npx prisma migrate deploy --schema=./prisma/schema.prisma && npx prisma migrate status --schema=./prisma/schema.prisma"]]}' \
            "$PRISMA_IMAGE_URI" "$DB_SECRET_ARN" "$AWS_REGION")

          # 2) Uvijek dodaj executionRoleArn; taskRoleArn po potrebi
          ROLES=$(printf '"executionRoleArn":"%s",' "$AWS_ECS_TASK_EXEC_ROLE_ARN")
          if [ -n "${AWS_ECS_TASK_ROLE_ARN:-}" ]; then
            ROLES=$(printf '%s"taskRoleArn":"%s",' "$ROLES" "$AWS_ECS_TASK_ROLE_ARN")
          fi

          # 3) Task Definition JSON
          printf '{"family":"uslugar-prisma-oneoff","networkMode":"awsvpc","cpu":"256","memory":"512","requiresCompatibilities":["FARGATE"],%s"containerDefinitions":[%s]}\n' \
            "$ROLES" "$CONTAINER" > prisma-td.json

          echo "----- prisma-td.json -----"
          cat prisma-td.json
          echo "--------------------------"

          # 4) Network config iz CSV SUBNETS -> JSON
          IFS=',' read -r -a _subs <<< "${SUBNETS}"
          SUBNET_ARRAY_JSON="["
          for i in "${!_subs[@]}"; do
            s="${_subs[$i]}"
            if [ $i -gt 0 ]; then SUBNET_ARRAY_JSON="${SUBNET_ARRAY_JSON}, "; fi
            SUBNET_ARRAY_JSON="${SUBNET_ARRAY_JSON}\"${s}\""
          done
          SUBNET_ARRAY_JSON="${SUBNET_ARRAY_JSON}]"

          printf '{"awsvpcConfiguration":{"subnets":%s,"securityGroups":["%s"],"assignPublicIp":"%s"}}\n' \
            "$SUBNET_ARRAY_JSON" "$SECGRP" "$ASSIGN_PUBLIC_IP" > netcfg.json

          echo "----- netcfg.json -----"
          cat netcfg.json
          echo "-----------------------"

          # 5) Register + run
          TD_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://prisma-td.json \
            --query "taskDefinition.taskDefinitionArn" --output text)
          echo "Registered TD: $TD_ARN"

          TASK_ARN=$(aws ecs run-task \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --launch-type FARGATE \
            --task-definition "$TD_ARN" \
            --network-configuration file://netcfg.json \
            --query "tasks[0].taskArn" --output text)

          echo "Task: $TASK_ARN"
          aws ecs wait tasks-stopped --cluster "${{ env.ECS_CLUSTER }}" --tasks "$TASK_ARN"

          EXIT=$(aws ecs describe-tasks \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --tasks "$TASK_ARN" \
            --query "tasks[0].containers[0].exitCode" --output text)
          echo "Exit code: $EXIT"
          test "$EXIT" = "0"
