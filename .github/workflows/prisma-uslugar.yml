name: Prisma - Build/Push & Migrate (ECR→ECS)

on:
  workflow_dispatch:
  push:
    branches: ["main"]
    paths:
      - "uslugar/backend/prisma/**"
      - "uslugar/backend/Dockerfile.prisma"
      - ".github/workflows/prisma-uslugar.yml"

env:
  AWS_REGION: eu-north-1
  ECR_REPO_PRISMA: uslugar-prisma-tasks
  ECS_CLUSTER: apps-cluster
  MIGRATE_SUBNETS: subnet-0a00f97768705bbcf,subnet-0546fb6cc0ad2cc37
  MIGRATE_SG: sg-084c1e49c9c77aff1

jobs:
  prisma:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Ensure package-lock.json (backend)
        working-directory: uslugar/backend
        run: |
          if [ ! -f package-lock.json ]; then
            npm i --package-lock-only
          fi
          ls -l package-lock.json || true

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - id: ecr-login
        uses: aws-actions/amazon-ecr-login@v2

      - name: Ensure ECR repo exists
        run: |
          aws ecr describe-repositories --repository-names "${{ env.ECR_REPO_PRISMA }}" >/dev/null 2>&1 || \
          aws ecr create-repository --repository-name "${{ env.ECR_REPO_PRISMA }}" >/dev/null

      - name: Build & Push prisma-tasks image (SHA + latest)
        env:
          ECR_REGISTRY: ${{ steps.ecr-login.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -f uslugar/backend/Dockerfile.prisma \
            -t $ECR_REGISTRY/${{ env.ECR_REPO_PRISMA }}:$IMAGE_TAG \
            -t $ECR_REGISTRY/${{ env.ECR_REPO_PRISMA }}:latest \
            uslugar/backend

          docker push $ECR_REGISTRY/${{ env.ECR_REPO_PRISMA }}:$IMAGE_TAG
          docker push $ECR_REGISTRY/${{ env.ECR_REPO_PRISMA }}:latest

          echo "PRISMA_IMAGE_URI=$ECR_REGISTRY/${{ env.ECR_REPO_PRISMA }}:$IMAGE_TAG" >> $GITHUB_ENV

      - name: Run Prisma migrate (one-off Fargate task)
        shell: bash
        env:
          SUBNETS: ${{ env.MIGRATE_SUBNETS }}
          SECGRP:  ${{ env.MIGRATE_SG }}
          ASSIGN_PUBLIC_IP: ENABLED
          AWS_REGION: ${{ env.AWS_REGION }}
          DB_SECRET_ARN: ${{ secrets.DB_SECRET_ARN }}
          AWS_ECS_TASK_EXEC_ROLE_ARN: ${{ secrets.AWS_ECS_TASK_EXEC_ROLE_ARN }}
          AWS_ECS_TASK_ROLE_ARN: ${{ secrets.AWS_ECS_TASK_ROLE_ARN }}
          ECS_CLUSTER: ${{ env.ECS_CLUSTER }}
        run: |
          set -euo pipefail

          if [ -z "${AWS_ECS_TASK_EXEC_ROLE_ARN:-}" ]; then
            echo "AWS_ECS_TASK_EXEC_ROLE_ARN je obavezan (potreban za 'secrets' i awslogs)."
            exit 1
          fi

          echo "Using PRISMA_IMAGE_URI=${PRISMA_IMAGE_URI}"

          sudo apt-get update -y >/dev/null
          sudo apt-get install -y jq >/dev/null

          # Osiguraj CloudWatch log group (ako ne postoji)
          LG_EXISTS=$(aws logs describe-log-groups \
            --log-group-name-prefix "/ecs/uslugar/prisma" \
            --query "logGroups[?logGroupName=='/ecs/uslugar/prisma'] | length(@)" \
            --output text || echo 0)
          if [ "${LG_EXISTS}" = "0" ]; then
            aws logs create-log-group --log-group-name "/ecs/uslugar/prisma" || true
          fi

          # container-definitions (validan JSON)
          cat > container.json <<EOF
          [
            {
              "name": "prisma",
              "image": "${PRISMA_IMAGE_URI}",
              "essential": true,
              "environment": [
                { "name": "PRISMA_OPENSSL_VERSION", "value": "3.0.x" }
              ],
              "secrets": [
                { "name": "DATABASE_URL", "valueFrom": "${DB_SECRET_ARN}:DATABASE_URL::" }
              ],
              "logConfiguration": {
                "logDriver": "awslogs",
                "options": {
                  "awslogs-region": "${AWS_REGION}",
                  "awslogs-group": "/ecs/uslugar/prisma",
                  "awslogs-stream-prefix": "oneoff"
                }
              },
              "command": [
                "sh","-lc",
                "npx prisma migrate resolve --rolled-back 20251021140000_add_support_tickets --schema=./prisma/schema.prisma || true && npx prisma migrate deploy --schema=./prisma/schema.prisma && npx prisma migrate status --schema=./prisma/schema.prisma"
              ]
            }
          ]
          EOF

          echo "----- container.json -----"
          cat container.json
          echo "-------------------------"

          # Registracija Task Definition-a (bez --cli-input-json da izbjegnemo YAML/JSON escaping)
          TD_ARN=$(aws ecs register-task-definition \
            --family uslugar-prisma-oneoff \
            --network-mode awsvpc \
            --cpu "256" \
            --memory "512" \
            --requires-compatibilities FARGATE \
            --execution-role-arn "$AWS_ECS_TASK_EXEC_ROLE_ARN" \
            ${AWS_ECS_TASK_ROLE_ARN:+--task-role-arn "$AWS_ECS_TASK_ROLE_ARN"} \
            --container-definitions file://container.json \
            --query "taskDefinition.taskDefinitionArn" \
            --output text)
          echo "TD_ARN=$TD_ARN"

          # Network config u zasebnom JSON-u (sigurno quotanje)
          cat > netcfg.json <<EOF
          {
            "awsvpcConfiguration": {
              "subnets": ["${SUBNETS//,/\",\"}"],
              "securityGroups": ["${SECGRP}"],
              "assignPublicIp": "${ASSIGN_PUBLIC_IP}"
            }
          }
          EOF

          echo "----- netcfg.json -----"
          cat netcfg.json
          echo "-----------------------"

          TASK_ARN=$(aws ecs run-task \
            --cluster "$ECS_CLUSTER" \
            --launch-type FARGATE \
            --task-definition "$TD_ARN" \
            --network-configuration file://netcfg.json \
            --query "tasks[0].taskArn" --output text)
          echo "Task: $TASK_ARN"

          aws ecs wait tasks-stopped --cluster "$ECS_CLUSTER" --tasks "$TASK_ARN"

          # Detaljna dijagnostika
          DESC=$(aws ecs describe-tasks --cluster "$ECS_CLUSTER" --tasks "$TASK_ARN")
          STATUS=$(echo "$DESC" | jq -r '.tasks[0].lastStatus')
          STOPPED_REASON=$(echo "$DESC" | jq -r '.tasks[0].stoppedReason // empty')
          CSTAT=$(echo "$DESC" | jq -r '.tasks[0].containers[0].lastStatus')
          EXIT=$(echo "$DESC" | jq -r '.tasks[0].containers[0].exitCode // empty')
          CREASON=$(echo "$DESC" | jq -r '.tasks[0].containers[0].reason // empty')

          echo "Task status: $STATUS ; container: $CSTAT ; exitCode: ${EXIT:-<none>} ; reason: ${CREASON:-<none>} ; stoppedReason: ${STOPPED_REASON:-<none>}"

          if [ "${EXIT:-}" = "0" ]; then
            echo "✅ Prisma migrations OK"
            exit 0
          fi

          # Pokušaj dohvatiti CloudWatch logove (oneoff/<container>/<taskId>)
          TASK_ID="${TASK_ARN##*/}"
          STREAM="oneoff/prisma/${TASK_ID}"
          echo "Trying to fetch CloudWatch logs: /ecs/uslugar/prisma :: ${STREAM}"
          aws logs get-log-events \
            --log-group-name "/ecs/uslugar/prisma" \
            --log-stream-name "$STREAM" \
            --limit 200 --output text || true

          echo "❌ Prisma migrate failed."
          exit 1

  seed:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    needs: prisma

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - id: ecr-login
        uses: aws-actions/amazon-ecr-login@v2

      - name: Get latest Prisma image
        env:
          ECR_REGISTRY: ${{ steps.ecr-login.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          PRISMA_IMAGE_URI="$ECR_REGISTRY/${{ env.ECR_REPO_PRISMA }}:$IMAGE_TAG"
          echo "PRISMA_IMAGE_URI=$PRISMA_IMAGE_URI" >> $GITHUB_ENV

      - name: Run Prisma seed (one-off Fargate task)
        shell: bash
        env:
          SUBNETS: ${{ env.MIGRATE_SUBNETS }}
          SECGRP:  ${{ env.MIGRATE_SG }}
          ASSIGN_PUBLIC_IP: ENABLED
          AWS_REGION: ${{ env.AWS_REGION }}
          DB_SECRET_ARN: ${{ secrets.DB_SECRET_ARN }}
          AWS_ECS_TASK_EXEC_ROLE_ARN: ${{ secrets.AWS_ECS_TASK_EXEC_ROLE_ARN }}
          AWS_ECS_TASK_ROLE_ARN: ${{ secrets.AWS_ECS_TASK_ROLE_ARN }}
          ECS_CLUSTER: ${{ env.ECS_CLUSTER }}
        run: |
          set -euo pipefail

          echo "Running Prisma seed with image: ${PRISMA_IMAGE_URI}"

          sudo apt-get update -y >/dev/null
          sudo apt-get install -y jq >/dev/null

          # container-definitions for seed
          cat > container-seed.json <<EOF
          [
            {
              "name": "prisma-seed",
              "image": "${PRISMA_IMAGE_URI}",
              "essential": true,
              "environment": [
                { "name": "PRISMA_OPENSSL_VERSION", "value": "3.0.x" }
              ],
              "secrets": [
                { "name": "DATABASE_URL", "valueFrom": "${DB_SECRET_ARN}:DATABASE_URL::" }
              ],
              "logConfiguration": {
                "logDriver": "awslogs",
                "options": {
                  "awslogs-region": "${AWS_REGION}",
                  "awslogs-group": "/ecs/uslugar/prisma",
                  "awslogs-stream-prefix": "seed"
                }
              },
              "command": [
                "sh","-lc",
                "npm run seed"
              ]
            }
          ]
          EOF

          echo "----- container-seed.json -----"
          cat container-seed.json
          echo "------------------------------"

          # Register Task Definition for seed
          TD_ARN=$(aws ecs register-task-definition \
            --family uslugar-prisma-seed-oneoff \
            --network-mode awsvpc \
            --cpu "256" \
            --memory "512" \
            --requires-compatibilities FARGATE \
            --execution-role-arn "$AWS_ECS_TASK_EXEC_ROLE_ARN" \
            ${AWS_ECS_TASK_ROLE_ARN:+--task-role-arn "$AWS_ECS_TASK_ROLE_ARN"} \
            --container-definitions file://container-seed.json \
            --query "taskDefinition.taskDefinitionArn" \
            --output text)
          echo "TD_ARN=$TD_ARN"

          # Network config
          cat > netcfg.json <<EOF
          {
            "awsvpcConfiguration": {
              "subnets": ["${SUBNETS//,/\",\"}"],
              "securityGroups": ["${SECGRP}"],
              "assignPublicIp": "${ASSIGN_PUBLIC_IP}"
            }
          }
          EOF

          TASK_ARN=$(aws ecs run-task \
            --cluster "$ECS_CLUSTER" \
            --launch-type FARGATE \
            --task-definition "$TD_ARN" \
            --network-configuration file://netcfg.json \
            --query "tasks[0].taskArn" --output text)
          echo "Seed Task: $TASK_ARN"

          aws ecs wait tasks-stopped --cluster "$ECS_CLUSTER" --tasks "$TASK_ARN"

          # Check status
          DESC=$(aws ecs describe-tasks --cluster "$ECS_CLUSTER" --tasks "$TASK_ARN")
          STATUS=$(echo "$DESC" | jq -r '.tasks[0].lastStatus')
          EXIT=$(echo "$DESC" | jq -r '.tasks[0].containers[0].exitCode // empty')
          CREASON=$(echo "$DESC" | jq -r '.tasks[0].containers[0].reason // empty')

          echo "Task status: $STATUS ; exitCode: ${EXIT:-<none>} ; reason: ${CREASON:-<none>}"

          if [ "${EXIT:-}" = "0" ]; then
            echo "✅ Prisma seed OK"
            exit 0
          fi

          # Fetch CloudWatch logs
          TASK_ID="${TASK_ARN##*/}"
          STREAM="seed/prisma-seed/${TASK_ID}"
          echo "Fetching CloudWatch logs: /ecs/uslugar/prisma :: ${STREAM}"
          aws logs get-log-events \
            --log-group-name "/ecs/uslugar/prisma" \
            --log-stream-name "$STREAM" \
            --limit 200 --output text || true

          echo "❌ Prisma seed failed."
          exit 1
